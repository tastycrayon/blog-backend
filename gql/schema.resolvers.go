package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.26

import (
	"context"
	"crypto/md5"
	"database/sql"
	"encoding/hex"
	"fmt"
	"log"
	"strconv"

	"github.com/mosiur404/goserver/db"
	"github.com/mosiur404/goserver/gql/generated"
	"github.com/mosiur404/goserver/gql/model"
	"github.com/mosiur404/goserver/middleware"
	"github.com/mosiur404/goserver/storage"
	"github.com/mosiur404/goserver/util"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// AddImage is the resolver for the addImage field.
func (r *mutationResolver) AddImage(ctx context.Context, imageTitle *string, imageURL string, thumbnailURL *string, height int, width int) (*model.MutationResponse, error) {
	if imageTitle == nil {
		imageTitle = new(string)
		*imageTitle = "Untitled"
	}
	if thumbnailURL == nil {
		thumbnailURL = new(string)
		*thumbnailURL = ""
	}

	args := &db.InsertImageParams{
		ImageTitle:   *imageTitle,
		ImageUrl:     imageURL,
		ThumbnailUrl: *thumbnailURL,
		Height:       height,
		Width:        width,
	}

	insertedId, err := r.Db.Queries.InsertImage(ctx, args)
	if err != nil {
		return nil, gqlerror.Errorf("Failed at resolver %v", err)
	}
	res := &model.MutationResponse{
		Code:    200,
		Success: true,
		Message: fmt.Sprintf("Successfully added image with ID %v. ðŸ¤ŸðŸ¤Ÿ", *insertedId),
		Result:  *insertedId,
	}
	return res, err
}

// AddPost is the resolver for the addPost field.
func (r *mutationResolver) AddPost(ctx context.Context, postTitle string, postSlug *string, postContent *string, authorid int64, imageID int64) (*model.MutationResponse, error) {
	if len(postTitle) < 3 {
		log.Panic("Title is too small")
	}

	if postContent == nil {
		postContent = new(string)
		*postContent = ""
	}
	if postSlug == nil {
		postSlug = new(string)
		*postSlug = *util.ParseSlug(postTitle)
	}

	args := &db.InsertPostParams{
		PostTitle:   postTitle,
		PostSlug:    *postSlug,
		PostContent: *postContent,
		Authorid:    authorid,
		ImageID:     imageID,
	}

	insertedId, err := r.Db.Queries.InsertPost(ctx, args)
	if err != nil {
		return nil, gqlerror.Errorf("Failed at resolver %v", err)
	}
	res := &model.MutationResponse{
		Code:    200,
		Success: true,
		Message: fmt.Sprintf("Successfully added post with ID %v. ðŸ¤ŸðŸ¤Ÿ", *insertedId),
		Result:  *insertedId,
	}
	return res, err
}

// PostImage is the resolver for the post_image field.
func (r *postResolver) PostImage(ctx context.Context, obj *db.Post) (*db.Image, error) {
	img, err := storage.For(ctx).GetImage(ctx, obj.PostImage)
	if err != nil {
		return nil, gqlerror.Errorf("Failed at resolver %v", err)
	}
	return img, err
}

// PostAuthor is the resolver for the post_author field.
func (r *postResolver) PostAuthor(ctx context.Context, obj *db.Post) (*db.User, error) {
	user, err := storage.For(ctx).GetUser(ctx, obj.PostAuthor)
	if err != nil {
		return nil, gqlerror.Errorf("Failed at resolver %v", err)
	}
	return user, err
}

// GetUsers is the resolver for the getUsers field.
func (r *queryResolver) GetUsers(ctx context.Context) ([]*db.User, error) {
	var u []*db.User
	users, err := r.Db.Queries.GetUsers(ctx)
	if err != nil {
		return nil, gqlerror.Errorf("Failed at resolver %v", err)
	}
	for i := range users {
		u = append(u, &users[i])
	}
	return u, nil
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, id int64) (*db.User, error) {
	user, err := r.Db.Queries.GetUser(ctx, id)
	if err != nil {
		return nil, gqlerror.Errorf("Failed at resolver %v", err)
	}
	return &user, nil
}

// GetPosts is the resolver for the getPosts field.
func (r *queryResolver) GetPosts(ctx context.Context, limit int, offset int, orderBy *string) ([]*db.Post, error) {
	if orderBy == nil {
		orderBy = new(string)
		*orderBy = "post_title"
	}

	params := &db.GetPostsParams{
		OrderBy: *orderBy, Limit: limit, Offset: offset,
	}
	var p []*db.Post
	posts, err := r.Db.Queries.GetPosts(ctx, params)
	if err != nil {
		return nil, gqlerror.Errorf("Failed at resolver %v", err)
	}
	for i := range posts {
		p = append(p, &posts[i])
	}

	return p, nil
}

// GetPostsWithCategory is the resolver for the getPostsWithCategory field.
func (r *queryResolver) GetPostsWithCategory(ctx context.Context, limit int, offset int, orderBy *string) ([]*db.PostCat, error) {
	if orderBy == nil {
		orderBy = new(string)
		*orderBy = "post_title"
	}

	params := &db.GetPostsParams{
		OrderBy: *orderBy, Limit: limit, Offset: offset,
	}
	var p []*db.PostCat
	posts, err := r.Db.Queries.GetPostsWithCategory(ctx, params)
	if err != nil {
		return nil, gqlerror.Errorf("Failed at resolver %v", err)
	}
	for i := range posts {
		p = append(p, &posts[i])
	}
	return p, nil
}

// GetPostsByCategory is the resolver for the getPostsByCategory field.
func (r *queryResolver) GetPostsByCategory(ctx context.Context, limit int, offset int, orderBy *string, cat string) ([]*db.Post, error) {
	if orderBy == nil {
		orderBy = new(string)
		*orderBy = "post_title"
	}

	params := &db.GetPostsByCatParams{
		OrderBy: *orderBy, Limit: limit, Offset: offset, Category: cat,
	}

	var p []*db.Post
	posts, err := r.Db.Queries.GetPostsByCategory(ctx, params)
	if err != nil {
		return p, gqlerror.Errorf("Failed at resolver %v", err)
	}
	for i := range posts {
		p = append(p, &posts[i])
	}

	return p, nil
}

// GetPost is the resolver for the getPost field.
func (r *queryResolver) GetPost(ctx context.Context, id int64) (*db.Post, error) {
	post, err := r.Db.Queries.GetPost(ctx, id)
	if err != nil {
		return nil, gqlerror.Errorf("Failed at resolver %v", err)
	}
	return &post, nil
}

// GetPostBySlug is the resolver for the getPostBySlug field.
func (r *queryResolver) GetPostBySlug(ctx context.Context, slug string) (*db.Post, error) {
	post, err := r.Db.Queries.GetPostBySlug(ctx, fmt.Sprintf("%%%v%%", slug))
	if err != nil {
		return nil, gqlerror.Errorf("Failed at resolver %v", err)
	}
	return &post, nil
}

// GetPostWithCatBySlug is the resolver for the getPostWithCatBySlug field.
func (r *queryResolver) GetPostWithCatBySlug(ctx context.Context, slug string) (*db.PostCat, error) {
	post, err := r.Db.Queries.GetPostWithCatBySlug(ctx, fmt.Sprintf("%%%v%%", slug))
	if err != nil {
		return nil, gqlerror.Errorf("Failed at resolver %v", err)
	}
	return post, nil
}

// GetPostCount is the resolver for the getPostCount field.
func (r *queryResolver) GetPostCount(ctx context.Context, cat *string) (int, error) {
	count, err := r.Db.Queries.GetPostCount(ctx, cat)
	if err != nil {
		return 0, gqlerror.Errorf("Failed at resolver %v", err)
	}
	return count, nil
}

// GetImage is the resolver for the getImage field.
func (r *queryResolver) GetImage(ctx context.Context, id int64) (*db.Image, error) {
	image, err := r.Db.Queries.GetImage(ctx, id)
	if err != nil {
		return nil, gqlerror.Errorf("Failed at resolver %v", err)
	}
	return &image, nil
}

// GetCategories is the resolver for the getCategories field.
func (r *queryResolver) GetCategories(ctx context.Context) ([]*db.Category, error) {
	var c []*db.Category
	categories, err := r.Db.Queries.GetCategories(ctx)
	if err != nil {
		return nil, gqlerror.Errorf("Failed at resolver %v", err)
	}
	for i := range categories {
		c = append(c, &categories[i])
	}

	return c, nil
}

// Login is the resolver for the login field.
func (r *queryResolver) Login(ctx context.Context, emailOrUsername string, password string) (*model.LoginResponse, error) {
	user, err := r.Db.Queries.GetUserByEmailOrUsername(ctx, emailOrUsername)

	if err == sql.ErrNoRows {
		return nil, util.GqlError(ctx, "User does not exist. ðŸ˜‘", util.BadUserInput)
	}
	if err != nil {
		return nil, gqlerror.Errorf("Failed at resolver %v", err)
	}

	algorithm := md5.New()
	algorithm.Write([]byte(password))
	hashedPassword := hex.EncodeToString(algorithm.Sum(nil))

	if hashedPassword != user.UserPass {
		return nil, util.GqlError(ctx, "Failed at resolver", util.BadUserInput)
	}

	refresh_token, expiry_date, err := middleware.GenerateRefreshToken(user.ID)
	if err != nil {
		return nil, util.GqlError(ctx, "Failed at resolver", util.InternalServerError)
	}

	access_token, _, err := middleware.GenerateAccessToken(user.ID)
	if err != nil {
		return nil, util.GqlError(ctx, "Failed at resolver", util.InternalServerError)
	}

	cookieManager := middleware.GetCookieAccess(ctx)
	cookieManager.SetToken(*refresh_token)

	exp := strconv.FormatInt(expiry_date, 10) // date to string
	result := &model.LoginResponse{
		AccessToken: access_token,
		Exp:         &exp,
	}
	return result, nil
}

// Logout is the resolver for the logout field.
func (r *queryResolver) Logout(ctx context.Context, emailOrUsername string, password string) (*bool, error) {
	panic(fmt.Errorf("not implemented: Logout - logout"))
}

// UserImage is the resolver for the user_image field.
func (r *userResolver) UserImage(ctx context.Context, obj *db.User) (*db.Image, error) {
	img, err := storage.For(ctx).GetImage(ctx, obj.UserImage)
	if err != nil {
		return nil, gqlerror.Errorf("Failed at resolver %v", err)
	}
	return img, err
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Post returns generated.PostResolver implementation.
func (r *Resolver) Post() generated.PostResolver { return &postResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type postResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
